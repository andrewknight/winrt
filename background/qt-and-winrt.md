# Qt and the WinRT API

## Windows 8 - a "Modern" operating system
From the user perspective, Windows 8 might be perceived as a hybrid of two quite different user experiences. For traditional use cases, the Windows 8 desktop experience is largely the same as previous versions of Windows, apart from the new "Start Screen", which replaces the Start Menu. The Start Screen is based on a grid of "tiles", a concept introduced in the Windows Phone 7 "Metro" UI. For PC users, it serves as the glue between the desktop (i.e. mouse/keyboard interaction) experience and the more touch-oriented "Modern" experience. For Windows RT devices - that is, ARM-powered Windows tablets and touch notebooks - the desktop experience is available, but is reserved for Microsoft system applications only. Therefore, the emphasis is pushed even further toward the Modern UI environment and, consequently, the availability of these applications in the Windows Store. On Windows Phone 8, there is, of course, no desktop experience at all, with a touch experience that feels like a trimmed-down version of the Windows 8 Modern UI.

<figure>
    <img src="../images/start-screen.jpg" alt="Windows 8 Start Screen" /><br />    
    <figcaption>Left: Windows 8 Desktop with Start Screen launcher in lower-left "hot corner" (detail). Right: sample Windows 8 Start Screen [microsoft.com](/appendix/references.md#windows-8-start-screen)</figcaption>
</figure>

For application developers, the three user environments (Desktop, Modern, Phone) have various levels of access to the WinRT API. Generally speaking, Desktop development continues to use the existing [Win32](/appendix/terms.md#win32), although many of the WinRT APIs have been made available there as well. Modern UI apps may use the complete [WinRT](/appendix/terms.md#winrt) API as well as some existing Win32 APIs which have been "blessed" for use within the Windows Store (these exceptions are documented on [MSDN](/appendix/terms.md#msdn)). Windows Phone ([WinPhone](/appendix/terms.md#winphone)) applications have access to most of the WinRT API (interfaces only for desktop devices, such as cursor handling, being a major exception) as well as a few additional APIs which only make sense in the context of a phone. With this API split, covering all three environments in the same application would not seem practical. However, handling cases for both the Modern UI and Windows Phone in the same application should be straightforward (while some applications, such as [Google Chrome](/appendix/references.md#chrome-winrt), provide both Desktop and Modern UI in the same application). Given that desktop Windows is already a well-covered platform for Qt, the WinRT port of Qt is quite sensibly limited to the Modern UI environment (PCs, tablets, and phones), and not intended to be used from the Windows Desktop.

As detailed in the previous [section](xplatform.md), Qt is authored in C++ and therefore requires a C++ (or C-like) interface in which to hook into the platform details. Like Win32 before it, WinRT is a native API. It is, however, a rather "raw" API, with the recommended access being from one of the several higher-level wrappers: .NET languages (including [C#](/appendix/terms.md#c-sharp) and [Visual Basic](/appendix/terms.md#visual-basic)), a new HTML/JavaScript framework, and a version of C++ with extensions called C++/CX. C++ and .NET developers may use the platform-styled [XAML](/appendix/terms.md#xaml) components, while web developers can opt for any HTML component set they see fit.

Developers utilizing the C++/CX will receive, among other things, automatic memory management of WinRT types through the use of (non-standard) smart pointers. This is accomplished through the use of compile-time metadata, but follows the syntax of the .NET language C++/CLI (hence being familiar to existing CLI programmers). While this may ease C++ development when compared to the traditional [COM](/appendix/terms.md#com) model, it will have the challenge of reducing source compatibility with other compilers, syntax highlighers, and code editors. The Qt Project tends to avoid these types of vendor-lockin symptoms when possible, and it was therefore decided that these [CX extensions would not be used in Qt source](/appendix/references.md#c++-cx-blog). This is possible because the WinRT API is available through a set of standard C/C++ headers generated from the interface description language ([IDL](/appendix/terms.md#idl)) for the libraries, and made available in the ABI (for [Abstract Binary Interface](/appendix/terms.md#abi)) namespace.

Microsoft's encouragement of developers to use the higher-level language options - especially those which might encourage vendor lockin - fuels the need for solutions like Qt. With the exception of the HTML toolkit, UI code reusability options will be minimal for developers seeking to port applications to (or from) the Windows Store. For the HTML toolkit, reusability in the UI may still remain challenging due to browser engine differences (most Cordova implementations use WebKit, not Internet Explorer), and particualarly challenging when custom native code solutions must be employed to extend the browser. Therefore, a niche opens up for targeting developers who wish for good cross-platform portability of source code - in much the same way as web technologies - with the advantage of access to the native platform. Compared to the provided XAML components, Qt's controls may not sufficiently mimic the platform's native control set, but this is something which can be remedied as the Qt components offering evolves. In effect, Qt promises WinRT programmers a balance between the convenience and flexibility of HTML (a high-level canvas technology, Qt Quick) with the portability and low-level granularity of a native programming language. Developers can choose Qt on WinRT both for its value as a UI technology and to avoid vendor lock-in with code that only runs on Windows-based systems.

## QPA Background
QPA is a mechanism introduced in Qt 4.8 under the Nokia project codename "Lighthouse". It was an important aspect in [Nokia's roadmap for Qt 5], as it improved the ease of developing platform support for (particularly Linux-based) platforms. While a Qt 5 product was never shipped by Nokia, Qt 5 did inherit the strengths of QPA and was subsequently released by [Digia in December 2012](/appendix/references.md#introducing-qt-50).

///move to background?
QPA primarily deals with the platform's windowing system - it provides glue between the expectations of Qt applications and the native APIs of the operating system's window manager (or lack thereof). It decides how to flush images to the screen, interfaces with the platform's user input system (i.e. keyboard, mouse, and touch), and provides hooks for native window styling/theming. It also provides an access layer for OpenGL, a key requirement for Qt Quick 2 applications.

///remove or move to background
Unlike the DWM, QPA is not responsible for composition - it is only an access layer to an abstract windowing system, which may or may not provide composition. In general, it provides a path for Qt applications to draw to the device's screen (or perhaps, even an [offscreen, in-memory surface](/appendix/terms.md#offscreen-rendering)!). This gives the platform implementer the freedom to provide only the needed entry points (e.g. framebuffer drawing and input handling) while leaving other portions (e.g. window decorations or platform theming) unimplemented if desired. Due to these minimalist requirements, the task of porting Qt to a new platform tends to be much easier as compared to QWS and the previous architecture of platform-specific private implementations ([PIMPLs](/appendix/terms.md#pimpl)). PIMPLs certainly still exist throughout Qt, but window management is handled completely within QPA.

The mechanism involves subclassing a QPlatform interface for each component of the port (Window, Screen, Cursor, Theme, etc.) and then wrapping all of these interfaces in a platform _plugin_, typically loaded dynamically at runtime. This loose coupling not only allows for easier porting, it also allows the user of the application to switch between different plugin offerings.

Even with the non-specific styling approach that Qt Quick offers, it is clear that developers are still interested in creating platform-styled UIs[][][]. For that reason, the [Qt Quick Controls](/appendix/terms.md#qt-quick-controls) add-on library was developed, with the intent of bringing much a widget-like API into Qt Quick, including a [new styling API](/appendix/references.md#qt-quick-styling) to give the flexibility and out-of-the-box platform look-and-feel back into Qt UI development. This brings the advantages of the scene graph and language features together with the traditional convenience of a platform look-and-feel. Existing desktop platform style plugins are reused, while new platforms (like WinRT) should utilize the new QML-based styling API.
