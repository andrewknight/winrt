# Cross-Platform Development

A citizen of the technology society likely interacts, whether actively or passively, with dozens of computing platforms each day: apart from the typical personal computer, workstation, and mobile phones, the "user" may rely on computing systems in automobiles, public transportation systems, digital signage, as well as countless other services operating remotely via the Internet. As computing becomes ever more ubiqitous, the variety of hardware and software configurations for different tasks becomes vast and complex. Each of these compatible configurations can be defined as a platform - a combination of a given machine (hardware) and operating system (software). With so many platforms in use - and many with similar goals - it becomes increasingly important for software to operate _cross-platform_.

## C++ as a cross-platform language
While UI frameworks tend to be the topic of cross-platform development in contemporary frameworks, the topic itself dates back at least to the earliest C compilers - even before UIs were graphical at all. The C language itself might be considered one of the original cross-platform "frameworks", as compilers translate platform-agnostic standard C procedures into machine code (which might be different for each machine). Having its roots in the [1960s](/appendix/references.md#c-history), C has endured and continues to be considered one of the [most portable languages in existence](/appendix/references.md#c-history). From the [Linux kernel] to the [Mars Rover], C is ubiquitous... not to mention that it forms the basis of C++ and a few dozen other languages[].

Given its basis on the language, C++ inherits much of the portability of C. The language itself, however, is no silver bullet - cross-platform [_libraries_](/appendix/terms.md#software-libary) are also needed to promote real portability, as they can help abstract platform-specific details from the programmer. This is one of the reasons the standard template library ([STL](/appendix/terms.md#stl)) was developed[] - not only to provide a solid foundation for which to use the language, but also to allow compiler vendors to provide their own implementations (and optimizations) for the high-level primitives that everyone is expected to use. Hence, C++ & STL continues to provide one of the most portable code models for applications today. C++/STL is available for Windows, Unix-style operating systems (Linux/BSD/Mac OS X), embedded/real-time operating systems (e.g. QNX & VxWorks) as well as mobile operating systems like [Android](/appendix/terms.md#android), [iOS](/appendix/terms.md#ios), and Windows Phone 8. Assumming an accurate implementation and support STL code can run nearly anywhere.

## GUI Portability
Despite STL's success, it is not comprehensive - it doesn't include any GUI-related classes, for example. For this reason, GUI applications tend to get "locked in" to a given UI library (typically the platform's) which is likely not as portable as the STL. While a developer might be able to use C (or C++) as a universal language, they are not typically able to use a given operating system's UI library on an incompatible operating system. Apart from switching to a language (and corresponding UI toolkit) that runs in a virtual machine (such as [Java]/[Swing] or [ActionScript]/[Flex]), the developer may opt for a C++ library that helps them write their UI in a cross-platform way. A high-level solution like [Apache Cordova](/appendix/terms.md#apache-cordova), which provides web application solutions for a variety of platforms, allows applications to use a set of "universal" standards like those defined by the [W3C](/appendix/terms.md#w3c) (colloquially known as [HTML5]). On the lower-level side of things exist graphics APIs such as [OpenGL], a highly portable C drawing library. The middle gound includes native toolkits such as Qt and [WxWidgets](/appendix/terms.md#wxwidgets), which aim to make platform toolkits equally accessible through a common API.

Native cross-platform toolkits like Qt or [WxWidgets](/appendix/terms.md#wxwidgets) are compiled against the platform's [SDK](/appendix/terms.md#sdk) (as opposed to being intepreted at runtime or compiled for a virtual machine). The toolkit provides an abstracted API (so that platform-specific code can be minimized) in a compilable language (such as C++) or possibly through interpreted bindings (e.g. Python). This has the advantage that users of the toolkit do not need to learn the platform UI library in order to work with the platform, and as long as the abstraction layer is thin (as is typical in C or C++), the performance difference should be negligible between the UI toolkit and using the platform APIs directly. It may have the risk of reduced flexibility or toolkit bugs being more difficult to diagnose (due to the constraints of the abstraction), but this is often mitigated by the availability of the toolkit's source code (both Qt and WxWidgets are available under [free and open source](/appendix/terms.md#foss) licenses), allowing programmers to modify the toolkit itself to fit their needs.

## Paradigm shift in cross-platform GUIs
This traditional approach to cross-platform development can be seen in Qt (as well as [SWT] and WxWidgets), which focus on the concept of "[widgets](/appendix/terms.md#widgets)", or UI components based directly on platform equivelants. This allows developers to use controls such as input elements, layout containers, and item views with predictable results cross-platform without rewriting source code. Up until the [Internet and smart device revolution] of recent years(/appendix/references.md#smart-device-revolution) - that is, before mobile and web UIs [overtook traditional desktop targets](/appendix/references.md#code-stats) - widgets made a solid and approachable paradigm for cross-platform GUIs. A problem, however, exists when the platform does not provide a UI library at all - then what platform-specific codepath can be used?

In the traditional approach, [painting](/appendix/terms.md#painting) - that is, the code which produces graphical output - is usually delegated to the native UI library. In some cases, this is simply not possible. This is why Qt uses a stylable paint engine, allowing the Qt library itself to control all painting of a given control. While in some cases, this is done purely for [performance benefits](/appendix/references.md#alien-widgets), there is the added benefit that platforms without a native [look-and-feel](/appendix/terms.md#look-and-feel) can be rendered with a default theme (e.g. Qt for Embedded Linux, which provides its own window manager) because the paint engine provides all component subroutines. It also means that when a platform doesn't provide a native version of a given control (e.g. the Windows Vista command button on a Mac), Qt can still provide the control styled with a "native" look-and-feel. Apart from native styling, toolkits like Swing have long used this approach as well: simply create a platform-specific surface to paint universal controls atop. This can be considered the same approach used by [Silverlight], [Flex] and even [HTML5] - all UI libraries which use a common canvas-style approach to painting UI components cross-platform.

Despite the success of the traditional, widget-based approach, the plethora of canvas-style UI frameworks should indicate a trend toward a more universal painting paradigm. After all, authoring native styles tends to be [tedious and error-prone](/appendix/references.md#style), and not every platform even has a native style, let alone a native UI library. For some platforms, it can be difficult to abstract all uses cases of the platform toolkit, causing highly platform-specific UI components to be [excluded as a result](figure showing platfrom components not covered by Qt). Furthermore, touch-based UIs tend to use markedly different UI mechanics compared to [mouse-based interaction](figure showing scrollbars vs flick), challenging the abstraction further. Owing to styling (look) and interactivity (feel) differences - and following the trends in UI development marked by technologies like HTML5 and JavaFX - Nokia chose to invest in a declarative, platform-agnostic approach to UI when it began the development of [Qt Quick in 2009](/appendix/terms.md#qt-quick). As Qt Quick matured, the demand for stylability persisted, prompting Digia to introduce [Qt Quick Controls](/appendix/terms.md#qt-quick-controls) to narrow the gap between the free-form canvas of Qt Quick and the native styling of Qt Widgets.

## Moving forward with Qt
Certainly, Qt is not alone in the cross-platform UI effort. Compared to most alternatives, Qt stands out by integrating directly with the platform's native SDK and toolchain, which means that it creates code which "speaks the language of the machine" and uses these native APIs behind the scenes. When compared to application runtime environments, such as those employed HTML5 solutions, the application should sit on more efficient codepaths and be granted better access to system resources such as graphics hardware and memory. The tradeoff, perhaps, is a steeper learning curve - programmers must learn more about the platform tools than they might need to do with e.g. Java. Despite this, the nearly [half-million developers using Qt](/appendix/references.md#qt-stats) should state something for Qt's richness and ease of entry.

Moving forward with Qt, it is important to note that WinRT is by no means the only actively developed new port for Qt 5. Besides the most mature (and visible) Android and iOS ports, there is also the [Qt Wayland] platform, the [QMir display plugin] from Canonical, the [BlackBerry 10 port], and a modified version of the Android port for Amazon's [Kindle DX]. In active development, these ports tend to help one another strengthen the cross-platform coverage of Qt as well as improving the internal APIs which Qt uses to bring these platforms into the light of day.

