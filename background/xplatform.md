# Cross-Platform Development

A citizen of the technology society likely interacts, whether actively or passively, with dozens of computing platforms each day: apart from the typical personal computer, workstation, and mobile phones, the "user" may rely on computing systems in automobiles, public transportation systems, digital signage, as well as countless other services operating remotely via the Internet. As computing becomes ever more ubiqitous, the variety of hardware and software configurations for different tasks becomes vast and complex. Each of these compatible configurations can be defined as a platform - a combination of a given machine (hardware) and operating system (software). With so many platforms in use - and many with similar goals - it becomes increasingly important for software to operate _cross-platform_.

## C++ as a cross-platform language
While UI frameworks tend to be the topic of cross-platform development in contemporary frameworks, the topic itself dates back at least to the earliest C compilers - even before UIs were graphical at all. The C language itself might be considered one of the original cross-platform "frameworks", as compilers translate platform-agnostic standard C procedures into machine code (which might be different for each machine). Having its roots in the 1960s, C has endured and continues to be considered one of the [most portable languages in existence](/appendix/references.md#c-as-a-universal-language). From the [Linux kernel](/appendix/references.md#who-writes-for-linux) to the [Mars Rover](/appendix/references.md#validated-toolchain-on-mars-rover), C is ubiquitous... not to mention that it forms the basis of C++ and many other languages.

Given its basis on C, C++ inherits much of its portability. The language itself, however, is no silver bullet - cross-platform [_libraries_](/appendix/terms.md#software-libary) are also needed to promote real portability, as they can help abstract platform-specific details from the programmer. This is one of the reasons the standard template library ([STL](/appendix/terms.md#stl)) [was developed](/appendix/terms.md#why-i-created-c) - not only to provide a solid foundation for which to use the language, but also to allow compiler vendors to provide their own implementations (and optimizations) for the high-level primitives that everyone is expected to use. Hence, C++ & STL continues to provide one of the most portable code models for applications today. C++/STL is available for Windows, Unix-style operating systems (Linux/BSD/Mac OS X), embedded/real-time operating systems (e.g. QNX & VxWorks) as well as mobile operating systems like [Android](/appendix/terms.md#android), [iOS](/appendix/terms.md#ios), and Windows Phone 8. Assumming an accurate implementation and support STL code can run nearly anywhere.

## GUI Portability
Despite STL's success, it is not comprehensive - it doesn't include any GUI-related classes, for example. For this reason, GUI applications tend to get "locked in" to a given UI library (typically the platform's) which is likely not as portable as the STL. While a developer might be able to use C (or C++) as a universal language, they are not typically able to use a given operating system's UI library on an incompatible operating system. Apart from switching to a language (and corresponding UI toolkit) that runs in a virtual machine (such as [JavaFX](/appendix/terms.md#javafx) or [Adobe Flex](/appendix/terms.md#adobe-flex)), the developer may opt for a C++ library that helps them write their UI in a cross-platform way. A high-level solution like [Apache Cordova](/appendix/terms.md#apache-cordova), which provides web application solutions for a variety of platforms, allows applications to use a set of "universal" standards like those defined by the [W3C](/appendix/terms.md#w3c) (i.e. [HTML5](/appendix/terms.md#html5)). On the lower-level side of things exist graphics APIs such as [OpenGL](/appendix/terms.md#opengl), the de-facto standard drawing API found on most platforms. The middle gound includes native toolkits such as Qt and [WxWidgets](/appendix/terms.md#wxwidgets), which aim to make platform toolkits equally accessible through a common API and a compiled language (in these cases, C++).

Native cross-platform toolkits like Qt are compiled against the platform's [SDK](/appendix/terms.md#sdk) (as opposed to being intepreted at runtime or compiled for a virtual machine). The toolkit provides an abstracted API (so that platform-specific code can be minimized) in a compiled library or possibly through interpreted bindings (e.g. Python). This has the advantage that users of the toolkit do not need to learn the platform UI library in order to work with the platform, and as long as the abstraction layer is thin (as is typical in C or C++), the performance difference should be negligible between the UI toolkit and using the platform APIs directly. It may have the risk of reduced flexibility or toolkit bugs being more difficult to diagnose (due to the constraints of the abstraction), but this is often mitigated by the availability of the toolkit's source code (both Qt and WxWidgets are available under [free and open source](/appendix/terms.md#foss) licenses), allowing programmers to modify the toolkit itself to fit their needs.

## Paradigm shift in cross-platform GUIs
The traditional approach to cross-platform GUI development - at least, from a desktop perspective - can be seen in Qt (as well as [SWT](/appendix/terms.md#swt) and WxWidgets), which focuses on the concept of "[widgets](/appendix/terms.md#widgets)", or UI components based directly on platform equivelants. This allows developers to use controls such as input elements, layout containers, and item views with predictable results cross-platform without rewriting source code. However, with an ever-growing momentum toward web and mobile UIs, the comparative development space for desktop development is shrinking. Even as mobile platforms develop their own UI toolkits and interaction patterns, the space to innovate upon a "blank canvas" becomes ever more attractive - especially when that canvas runs everywhere.

In the traditional approach, [painting](/appendix/terms.md#painting) - that is, the code which produces graphical output of the UI components - is commonly delegated to the platform library, at least with desktop environments. In some cases - such as when there simply isn't a platform UI toolkit - this is not possible. Qt solves this via a stylable paint engine, allowing the Qt library itself to control all painting of a given control. While in some cases, this is done purely for [performance benefits](/appendix/references.md#alien-widgets), there is the added benefit that platforms without a native [look-and-feel](/appendix/terms.md#look-and-feel) can be rendered with a default theme (e.g. Qt for Embedded Linux, which provides its own window manager) because the paint engine provides all component subroutines. It also means that when a platform doesn't provide a native version of a given control (e.g. the Windows Vista command button on a Mac), Qt can still provide the control styled with a "native" look-and-feel. Apart from native styling, toolkits like Swing have long used this approach as well: simply create a platform-specific surface to paint universal controls atop. This is not a new approach, and can be considered the standard paradigm by any toolkit lacking a "native" library - including Silverlight, Flex and even HTML5; these UI toolkits share common canvas-style approach to painting UI components cross-platform.

Despite the success of the traditional, widget-based approach, the abundance of canvas-style UI frameworks should indicate a trend toward a more universal painting paradigm. After all, authoring native styles tends to be [tedious and error-prone](/appendix/references.md#style), and not every platform even has a native style, let alone a native UI library. For some platforms, it can be difficult to abstract all uses cases of the platform toolkit, causing highly platform-specific UI components to be excluded as a result - and leading to "add-on" libraries such as [Qt Extras](/appendix/terms.md#qt-extras). Furthermore, touch-based UIs tend to use markedly different UI mechanics compared to mouse-based interaction, challenging the abstraction further. Owing to styling (look) and interactivity (feel) differences - and following the trends in UI development marked by technologies like HTML5 and JavaFX - Nokia chose to invest in a declarative, platform-agnostic approach to UI when it began the development of [Qt Quick in 2009](/appendix/terms.md#qt-quick). As Qt Quick matured, the demand for stylability persisted, prompting Digia to introduce [Qt Quick Controls](/appendix/terms.md#qt-quick-controls) to narrow the gap between the free-form canvas of Qt Quick and the native styling of Qt Widgets.

## Moving forward with Qt
Certainly, Qt is not alone in the cross-platform UI effort. Compared to most alternatives, Qt stands out by integrating directly with the platform's native SDK and toolchain, which means that it creates code which "speaks the language of the machine" and uses these native APIs behind the scenes. When compared to application runtime environments, such as those employed HTML5 solutions, the application should sit on more efficient codepaths and be granted better access to system resources such as graphics hardware and memory. The tradeoff, perhaps, is a steeper learning curve - programmers must learn more about the platform tools than they might need to do with e.g. Java. Despite this, the nearly [half-million developers using Qt](/appendix/references.md#qt-stats) should state something for Qt's richness and ease of entry.

Moving forward with Qt, it is important to note that WinRT is by no means the only actively developed new port for Qt 5. Besides the most mature (and visible) Android and iOS ports, there is also the [Qt Wayland](/appendix/terms.md#qt-wayland) platform, the [QMir display plugin](/appendix/terms.md#qmir) from Canonical, the [BlackBerry 10 port](/appendix/terms.md#bb10), and even a port for [Tizen](/appendix/terms.md#tizen), a platform originally desgined to be HTML5-only. In active development, these ports tend to help one another strengthen the cross-platform coverage of Qt as well as improving the internal APIs which Qt uses to bring these platforms into the light of day.

It is this cross-platform story that Qt has developed relied upon and reinforced the past two decades that makes WinRT such a viable platform for use with Qt. The foundation and tooling are already there - only a few bricks and a bit of mortar are required to build up Qt (and Qt Quick) into a usable toolkit for use on WinRT devices. The remainder of this chapter documents the foundational elements of the port and what architectural challenges await.

[Previous: Introduction](../intro/intro.md) | [Next: Qt and the WinRT API](qt-and-winrt.md)
