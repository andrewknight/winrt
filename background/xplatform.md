# Cross-Platform Development

A denizen of the technology society interacts, whether actively or passively, with dozens of computing platforms each day: apart from the typical personal computer, workstation, or mobile phone, the user may rely on computing systems in automobiles, public transportation systems, digital signage, as well as services operating remotely within the "cloud". As computing becomes ever more ubiqitous, the variety of hardware and software configurations for different tasks becomes vast and complex. Each of these compatible configurations can be defined as a platform - a combination of a given machine (hardware) and operating system (software). With so many platforms in use - and many with similar goals - it becomes increasingly important for software to operate *cross-platform*.

## C++ as a cross-platform language
While GUI construction tends to be the topic of cross-platform development in contemporary frameworks, the issue itself dates back at least to the earliest C compilers - even [before UIs were graphical at all](/appendix/references.md#citation-needed). The C language itself might be considered one of the original cross-platform "frameworks", as compilers translate platform-agnostic standard C procedures into machine code (which might be different for each machine). Having its [roots in the 1960s](/appendix/references.md#citation-needed), C has endured and continues to be considered one of the [most portable languages in existence](/appendix/references.md#c-as-a-universal-language). From the [Linux kernel](/appendix/references.md#who-writes-for-linux) to the [Mars Rover](/appendix/references.md#validated-toolchain-on-mars-rover), C is ubiquitous... not to mention that it forms the basis of C++ and many other languages.

Given its foundation, C++ inherits much of the portability of C. The language itself is no silver bullet, though - it also takes cross-platform tools and [*libraries*](/appendix/terms.md#software-libary) to promote real source portability, allowing for an abstraction of the platform-specific details met by the programmer. For strong adoption, the cross-platform library should use a royalty-free API to allow use anywhere, preferably with free and open source implementations to back it. This is one of the reasons the standard template library ([STL](/appendix/terms.md#stl)) [was developed](/appendix/terms.md#why-i-created-c) - not only to provide a solid foundation for which to use the language, but also to allow compiler vendors to provide their own implementations (and optimizations) for the high-level primitives STL provides. Hence, C++ & STL continues to provide one of the most portable code models for applications today, being used on Windows, Unix-style operating systems (Linux/BSD/Mac OS X), and embedded/real-time operating systems (e.g. QNX & VxWorks), as well as mobile operating systems like [Android](/appendix/terms.md#android), [iOS](/appendix/terms.md#ios), and Windows Phone 8. Assuming a compliant implementation exists for the platform (ideally available by default), STL source code should be compilable and runnable there.

## GUI Portability
Despite STL's success, it is not comprehensive - it doesn't include any GUI-related classes, for example. For this reason, GUI applications tend to get "locked in" to a given library (typically the platform's) which is likely not as portable as the STL. While a developer might be able to use C (or C++) as a universal language, they are not typically able to use a given operating system's UI library on an incompatible operating system. Apart from switching to a language (and corresponding UI toolkit) that runs in a virtual machine (such as [JavaFX](/appendix/terms.md#javafx) or [Adobe Flex](/appendix/terms.md#adobe-flex)), the developer may opt for a C++ library that helps them write their UI in a cross-platform way. A high-level solution like [Apache Cordova](/appendix/terms.md#apache-cordova), which provides web application solutions for a variety of platforms, allows applications to use a set of "universal" standards like those defined by the [W3C](/appendix/terms.md#w3c) (i.e. [HTML5](/appendix/terms.md#html5)). On the lower-level side of things exist graphics APIs such as [OpenGL](/appendix/terms.md#opengl), the de-facto standard drawing API found on most platforms. The middle gound includes native toolkits such as Qt and [WxWidgets](/appendix/terms.md#wxwidgets), which aim to make platform toolkits equally accessible through a common API and a compiled language such as C++.

Native cross-platform toolkits like Qt are compiled against the platform's [SDK](/appendix/terms.md#sdk) (as opposed to being intepreted at runtime or compiled for a virtual machine). The toolkit provides an abstracted API (so that platform-specific code can be minimized) in a compiled library or possibly through interpreted bindings (e.g. Python). This has the advantage that users of the toolkit do not need to learn the platform UI library in order to work with the platform, and as long as the abstraction layer is thin (as is typical in C or C++), the performance difference should be negligible between the UI toolkit and using the platform APIs directly. It may have the risk of reduced flexibility or toolkit bugs being more difficult to diagnose (due to the constraints of the abstraction), but this is often mitigated by the availability of the toolkit's source code (both Qt and WxWidgets are available under [free and open source](/appendix/terms.md#foss) licenses), allowing programmers to modify the toolkit itself to fit their needs.

## Paradigm shift in cross-platform GUIs
The traditional approach to cross-platform GUI development, at least, from a desktop perspective, can be seen in frameworks like Qt, [SWT](/appendix/terms.md#swt), and WxWidgets. In fact, the latter two have the term right in their name: "[widget](/appendix/terms.md#widgets)". Widgets, in this sense, are UI components based directly on platform equivelants but generalized across the platforms the toolkit supports, e.g. push buttons or context menus. This allows developers to use controls such as input elements, layout containers, and item views with predictable results cross-platform without rewriting source code. While valuable in the desktop space, it does not always translate well to mobile, embedded, or web UIs. With an ever-growing momentum toward web and mobile UIs, the comparative development space for desktop development is shrinking. Even as mobile platforms develop their own UI toolkits and interaction patterns, the space to innovate upon a "blank canvas" becomes ever more attractive - especially when that canvas runs everywhere - even desktop.

In the traditional approach, [painting](/appendix/terms.md#painting) - that is, the code which produces graphical output of the UI components - is commonly delegated to the platform library, at least with desktop environments. In some cases - such as when there simply isn't a platform UI toolkit - this is not possible. Qt solves this via a stylable paint engine, allowing the Qt library itself to control all painting of a given control. While in some cases, this is done purely for [performance benefits](/appendix/references.md#alien-widgets), there is the added benefit that platforms without a native [look-and-feel](/appendix/terms.md#look-and-feel) can be rendered with a default theme (e.g. Qt for Embedded Linux, which provides its own window manager) because the paint engine provides all component subroutines. It also means that when a platform doesn't provide a native version of a given control (e.g. the Windows Vista command button on a Mac), Qt can still provide the control styled with a "native" look-and-feel. Apart from native styling, toolkits like Swing have long used this approach as well: simply create a platform-specific surface to paint universal controls atop. While not a new approach, it can be considered the standard paradigm by any toolkit lacking a "native" library - including Silverlight (XAML), Flash (Flex) and even web applications (HTML): all of these toolkits answer the cross-platform question with a canvas-style approach to painting UI controls.

Despite the success of the traditional, widget-based approach, the abundance of canvas-style UI frameworks should indicate a trend toward a more universal painting paradigm. After all, authoring native styles tends to be [tedious and error-prone](/appendix/references.md#style), and not every platform even has a defined look-and-feel, let alone a native UI library. For some platforms, it can be difficult to abstract all uses cases of the platform toolkit, causing highly platform-specific UI components to be excluded as a result - and leading to "add-on" libraries such as [Qt Extras](/appendix/terms.md#qt-extras). Furthermore, touch-based UIs tend to use markedly different UI mechanics compared to mouse-based interaction, challenging the abstraction further. Owing to styling (look) and interactivity (feel) differences - and following the trends in UI development marked by technologies like HTML5 and JavaFX - Nokia chose to invest in a declarative, platform-agnostic approach to UI when it began the development of [Qt Quick in 2009](/appendix/terms.md#qt-quick). As Qt Quick matured, the demand for stylability persisted, prompting Digia to introduce [Qt Quick Controls](/appendix/terms.md#qt-quick-controls) to narrow the gap between the free-form canvas of Qt Quick and the native styling of Qt Widgets.

## Moving forward with Qt
Certainly, Qt is not alone in the cross-platform UI effort. Compared to most alternatives, Qt stands out by integrating directly with the platform's native SDK and toolchain, which means that it creates code which "speaks the language of the machine" and uses these native APIs behind the scenes. When compared to application runtime environments, such as those employed HTML5 solutions, the application should sit on more efficient codepaths and be granted better access to system resources such as graphics hardware and memory. The tradeoff, perhaps, is a steeper learning curve - programmers must learn more about the platform tools than they might need to do with e.g. Java. Despite this, the nearly [half-million developers using Qt](/appendix/references.md#qt-stats) should state something for Qt's richness and ease of entry.

Moving forward with Qt, it is important to remember that WinRT is not the only actively developed new port for Qt 5. Besides the most mature (and visible) Android and iOS ports, there is also the [Qt Wayland](/appendix/terms.md#qt-wayland) platform, the [QMir solution](/appendix/terms.md#qmir) from Canonical, the [BlackBerry 10 port](/appendix/terms.md#bb10), and even a port for [Tizen](/appendix/terms.md#tizen) - a Linux-based OS originally envisioned to allow only apps built with HTML5. In active development, these ports tend to help one another strengthen the cross-platform coverage of Qt as well as improving the internal APIs which Qt uses to bring these platforms into the light of day.

It is this cross-platform story that Qt has developed relied upon and reinforced the past two decades that makes WinRT such a viable platform for use with Qt. The foundation and tooling are already there - only a few bricks and a bit of mortar are required to build up Qt (and Qt Quick) into a usable toolkit for use on WinRT devices. The remainder of this chapter documents the foundational elements of the port and what architectural challenges await.

[Previous: Introduction](../intro/intro.md) | [Next: Qt and the WinRT API](qt-and-winrt.md)
