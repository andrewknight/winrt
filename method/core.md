# Core issues

One of the first steps to evaluating the state of any C++ source code is to compile (and link) it. For large projects, this usually requires installing dependencies and utilizing a build system to configure the build. Qt is no different; it uses its own build system based on a configuration bootstrap utilitiy and the Qt makefile generator, [qmake](/appendix/terms.md#qmake). Given the size of Qt, building it on a new platform is bound to reveal missing (or changed) APIs, unavailable libraries, compiler incompatibilities, or build system hiccups. In the case of WinRT, thankfully, the native build system is the same as is already in use for Desktop Windows, so makefiles generated by qmake can be used still be used with [nmake](/appendix/terms.md#nmake) and the Microsoft Visual Studio Compiler ([MSVC](/appendix/terms.md#msvc)). Few external dependencies are required for Qt, and they are typically shipped along with Qt inside the *3rdparty* directory. Most dependencies can be disabled at configure time if they pose compatibility issues, typically in the loss of certain features within Qt. Also useful - as compared to Qt 4 - is Qt 5's improved modularity, making it simpler to compile parts of Qt independently of others. Through the flexibility of the build system to disable unneeded features and the ability to use existing codepaths inherited from Desktop Windows, the number of WinRT-specific adjustments could be minimized. This section describes the more important changes required within the build system and core Qt libraries.

## Build System Changes
To cover the WinRT port, there are actually five different compilation targets to be considered - Windows 8 x86 32-bit, Windows 8 x86 64-bit, Windows RT ARM, Windows Phone ARM, and Windows Phone x86 (Emulator). Each of these environments comes with its own compiler variant and libraries - some even have a different set of system headers. To deal practically with all variations, a make specification - or "[mkspec](/appendix/terms.md#mkspec)" - [is defined for each compilation target](/appendix/gerrit.md#39875). The mkspec informs the Qt build system about the necessary paths and executables for not only building Qt applications, but also Qt itself. All WinRT mkspecs have been written with a common base mkspec, allowing settings to be shared wherever possible.

A number of build system changes were required in order to ensure proper support for Qt applications and to configure Qt itself. Many of these changes were contributed by community members, notably [Kamil Trzci≈Ñski](/appendix/references.md#ayufan-qt-5-and-winrt), during the project's early stages. Changes to the configuration tool, configure.exe, allowed for certain parts of Qt to be left out of the compilation process, thus allowing few dependencies in exchange for potentially missing features. For example, the SQLite Qt plugin needed to be [disabled on Windows Phone](/appendix/gerrit.md#54438) due to [missing memory mapping APIs](/appendix/gerrit.md#54225). While native WinRT builds use the same compiler for both the host tools and the Qt libraries, cross-compiled builds (such as those for Windows Phone) require a clean "sub-environment" for which to build the non-native binaries in. Fortunately, Windows CE build support already faces the same issue, so [Window Phone support](/appendix/gerrit.md#54495) was able to be added in a similar fashion.

## Core Library Changes
With make specifications and improvements to configure and qmake, the build system was now functional. The next step required working through the core functionality and removing, hiding, or replacing APIs which were incompatible with WinRT.

### Environment Variables
Apart from setting the environment via the debugger (discussed later in the [Tooling](tooling.md) chapter), it is not possible for the application to access or set environment variables - or, more accurately, the sandboxed environment does not import global environment variables into the application's runtime environment. Therefore, it was decided that the WinRT port would simply write to/from a global in-memory map to emulate the functionality of environment variables. This is useful, as many parts of Qt change behavior based on variables within the environment; the developer is still able to change this behavior by ["setting" the variable in code](/appendix/gerrit.md#46916). It does, however, limit the traditional use cases of an exposed environment, and developers must find different ways to affect post-compilation behavior of their applications.

### File System
Within the WinRT sandbox, apps may only access files within the application package or, with permission, user media directories. Therefore, it is best to access files using relative paths, with the root of the filesystem being the directory where the application is stored (as opposed to absolute paths). Apart from the app being aware of its location due to the path being [passed at startup](/appendix/gerrit.md#51187), there is little need for the absolute path of the application in general - all local resources must be obtained from within the app package (that is, the installation path). This is particularly important in Qt for plugin loading, as the modularized nature of Qt requires that plugins be dynamically loaded at runtime. [Several changes](/appendix/gerrit.md#39166) [were required](/appendix/gerrit.md#52251) to make file handling act more "relative" in cases where Qt accessed files directly. Much of this work was done by Maurice Kalinowski, who continues investigating the related tasks of packaging and deployment of [Qt as a WinRT framework](/appendix/references.md#introduction-to-windows-rt-frameworks).

### Threading
WinRT introduces a number of new threading primitives for use within parallel programming. Threading is very important in Qt UIs, as Qt relies heavily on the concept of a main "GUI" thread and any number of "worker" threads for non-GUI tasks; the Qt Quick Scene Graph even adds a threaded rendering system for offloading rendering tasks into a non-GUI thread. While it does not cover every QThread use case, [C++11's](/appendix/terms.md#c11) std::thread is available on WinRT and was used to replace the existing [Win32 threading calls](/appendix/gerrit.md#46916). Additionally, the Thread Local Storage (TLS) API was replaced with usage of the "thread" compiler attribute. The remaining Win32 unsupported APIs, such as WaitForMultipleObjects, could be replaced with their supported equivalents, such as WaitForMultipleObjectsEx. While threading is mostly functional at this point, future research into the Windows.Threading API namespace could allow more complete threading support in the future.

### Networking
Like threading, a complete discussion of network on WinRT is outside the scope of this thesis. Nonetheless, it is worthwhile to mention a few aspects of the [Qt Network](/appendix/terms.md#qt-network) port for WinRT, especially since QtQuick depends on QtNetwork for its network transparency support. Networking presents a rather large challenge on WinRT due to the Windows Sockets (WinSock2) API being dropped for WinRT and replaced by the Windows.Networking namespace. Curiously, Windows Phone supports the existing WinSock2 API, suggesting that existing Win32 codepaths can be utilized for the Windows Phone version of Qt (although not other devices). To this effect, [initial commits](/appendix/gerrit.md#46916) fixed up the WinSock2 codepaths for Windows Phone, while splitting up the functionality so that networking could be [temporarily disabled elsewhere](/appendix/gerrit.md#47039). Given that a code split is not very practical in the long-run (and that networking needs to work on PC as well), it was decided that the entire network stack be ported to WinRT's new networking APIs, allowing the WinSock2 calls to be removed altogether. In order to move on to more graphics-oriented work, a [compilation workaround](/appendix/gerrit.md#52235) was added. The complete QtNetwork port is an ongoing effort done primarily by Oliver Wolff.

## Bootstrapping Qt
With most of the non-GUI parts fixed up, building Qt (and Qt applications) was getting closer. One of the more rewarding moments in application development is when the app itself is shown on the screen for the first time - the "Hello World" moment. Due to the application container used in WinRT, a few adjustments to the application startup process needed to be made.

The first challenge to tackle was adjusting the COM multi-threading environment of WinRT. Qt requires that applications perform most GUI operations within the GUI thread, which is typically the main thread implied by the C runtime ([CRT](/appendix/terms.md#crt)) entry point (i.e. `main()`). WinRT's Appx container, however, does not run in this thread: WinRT creates and initializes the application container from a separate thread. This allows the application container to support multiple application states (normal display, background task, suspended), as well as allowing the application to be *activated* by many different means (such as file associations, URL schemes, or the Start Screen) without restarting the CRT main. This also contributes to the application security model; if an executable is invoked directly, the system will terminate it when the application container is accessed. When this CRT "stub" is run, it must create an application view [factory class](/appendix/terms.md#factory-class) which is passed back to the launcher for instatiation. This view factory calls the `Run()` method, which becomes the *logical* application entry point. For use of Qt within this environment, the [QGuiApplication](/appendix/qdoc.md#qguiapplication) instance must be created from within this method - preferably while being transparent to the developer.

![Bootstrap Design](/images/bootstrap.png)
^ Design of the WinRT bootstrap to hide implementation detail from the programmer

Fortunately, the process of "bootstrapping" a Qt application with a private main entry point is fairly common across Qt platforms. In Qt for Windows, this is accomplished by a static library called qtmain (found in qtbase/src/winmain), which does some initial setup before calling the main() entry point defined by the programmer. For WinRT, qtmain was modified to have [an alternative WinRT codepath](/appendix/gerrit.md#39876) which instantiates the needed WinRT classes and then passes control to the programmer's own `main()` function. A convenient workaround, the Unicode `wmain` CRT entry point, was used to avoid conflicts with the programmer's `main` function. Arguments from `wmain` are combined with any activation parameters (e.g. from the Start Screen or a file type association) and the application's `main` is invoked with the combined argument list. Elegantly, this allows Qt for WinRT applications to require no additional configuration or manipulation of the source code in order to operate within the application container - users of Qt are able to write their main entry point as they would on any other platform.

[Previous: Requirements for a Successful Port](../background/requirements.md) | [Next: Platform Abstraction](qpa.md)
