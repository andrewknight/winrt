## Core issues

One of the most obvious steps to checking the state of C++ source code is to compile (and link) it. Besides ensuring proper syntax and API usage, it can also check that the required symbols (e.g. from external libraries) are present. Given the size of Qt, compiling it on a new platform is bound to reveal missing (or changed) APIs, unavailable libraries, or compiler incompatibilities. In the case of WinRT, thankfully, the compiler itself hasn't changed much from previous versions of the Microsoft Visual Studio Compiler ([MSVC](/appendix/terms.md#msvc)), so makefiles generated by [qmake](/appendix/terms.md#qmake) can be used still be used with [nmake](/appendix/terms.md#nmake). For external dependencies, most of Qt's needs are covered in the "3rdparty" directory - many of which can be disabled if necessary. From a build system perspective, WinRT keeps pace with Windows Desktop and Windows CE - inheriting most of its PIMPL details from these two existing ports. Also useful - as compared to Qt 4 - is Qt 5's improved modularity, making it simpler to compile parts of Qt independently of others. The remaining wrinkles can be ironed out through WinRT-specific codepaths.

## Implementation details
Undoubtedly, most platform-specific and low-level code lives within the [qtbase](/appendix/terms.md#qtbase) repository, the home for essential modules like [Qt Core](/appendix/terms.md#qt-core) and [Qt Gui](/appendix/terms.md#qt-gui). Qt modules typically correspond to a single dynamically linked library and set of public headers for use in Qt applications. While they may have dependencies on other modules (e.g. all modules depend on Qt Core), they remain generally independent. Qt Core comprises the most essential elements of the framework - basic types (such as string and container handling), file system input/output ([I/O](/appendix/terms.md#io)), the [meta object system](/appendix/terms.md#meta-object-system) (including properties and signals/slots), and the event system. For the most part, Qt Core is made up of portable code already; only the file system and event dispatch portions tend to require platform-specific PIMPLs. Getting these PIMPLs adjusted allows opens the door for the remainder of the framework to be built. In many cases, Win32 APIs can simply be replaced by the extended ("Ex") or second ("2") version of the function (e.g. WaitForObjectsEx or CreateFile2) - it all depends on the particular use case.

### Make specifications
To completely cover the WinRT port, there are actually five different compilation environments that must be considered - Windows 8 x86 32-bit, Windows 8 x86 64-bit, Windows RT ARM, Windows Phone ARM, and Windows Phone x86 (Emulator). Each of these environments comes with its own compiler variant and libraries - some even have a different set of system headers. To deal practically with all variations, a make specification - or "[mkspec](/appendix/terms.md#mkspec)" - [is defined for each compilation target](/appendix/gerrit.md#make-specification). The mkspec informs the Qt build system about the necessary paths and executables for not only building Qt applications, but also Qt itself. All WinRT mkspecs have been written with a common "parent" mkspec, which allows sharing of settings wherever possible.

### Build system changes
A number of [build system](/appendix/gerrit.md#build-system) changes were required in order to ensure proper support for Qt applications and to configure Qt itself.

### File System Changes
Once compilation was in order, one of the first code-level issues to tackle was the file system - particularly how file paths are handled. Within the WinRT sandbox, apps may only access files within the application package (read-only) or data folder (read/write). Therefore, it is best to access files using relative paths, with the root of the filesystem being the directory where the application is stored (as opposed to using absolute paths to the files). Apart from the app being aware of its location due to the path being passed at startup, there is little need for this information in general - all local resources must be obtained from within the app package (that is, the installation path). This is particularly important in Qt for plugin loading, as the modularized nature of Qt suggests that plugins tend to be dynamically loaded frequently. In order to get up and running, [several changes](/appendix/gerrit.md#file-handling) were required to make file handling act more "relative" in cases where Qt accessed files directly.

### Environment variables
Apart from setting the environment with the debugger (discussed in the [Tooling](tooling.md) chapter), it is not possible for the application to access or set environment variables - or, more accurately, the sandboxed environment does not import global environment variables into the application's runtime environment. Therefore, the WinRT port simply writes to/from a global in-memory map to emulate the functionality of environment variables. This is useful, as many parts of Qt change behavior based on variables within the environment; the developer is still able to change this behavior by ["setting" the variable in code](/appendix/gerrit.md#base-system). It does, however, limit the traditional use cases of an exposed environment; developers must find different ways to affect post-compilation behavior of their applications.

### Threading
WinRT introduces a number of new threading primitives for use within parallel programming. Threading work was primarily a straightforward [shift to use of std::thread](/appendix/gerrit.md#base-system), a feature of the [C++11](/appendix/terms.md#c11) STL. In addition to replacing Win32 threads with std::thread, the Thread Local Storage (TLS) API was replaced with usage of the "thread" compiler attribute. The remaining Win32 unsupported APIs, such as WaitForMultipleObjects, could be replaced with their supported equivalents, such as WaitForMultipleObjectsEx.

### Networking
While networking is outside the scope of this thesis, it is worthwhile to mention a few aspects of the [Qt Network](/appendix/terms.md#qt-network) port for WinRT, especially since some of the socket programming code lives within Qt Core. Networking presents one of the more interesting challenges in WinRT due to the rather large changes made in the Windows API for these tasks - primarily, the fact that the Windows Sockets (WinSock2) API is unavailable in WinRT. Curiously, Windows Phone supports the existing WinSock2 API, meaning that existing codepaths can work on phones (but not other devices). To this effect, [initial commits](/appendix/gerrit.md#networking) fixed up the WinSock2 codepaths for Windows Phone, while splitting up the functionality so that networking could be [temporarily disabled elsewhere](/appendix/gerrit.md#event-system). Given that a code split is not very practical in the long-run (and that networking needs to work on PC as well), it was decided that the entire network stack be ported to WinRT's new networking APIs, allowing the WinSock2 calls to be removed altogether. This work is ongoing.

## Bootstrapping a Qt App
One of the more rewarding moments in application development is when the app itself is shown on the screen for the first time - in the case of running Qt on a new platform, at least. Due to the application container used in WinRT, a few adjustments to the application startup process needed to be made.

The first challenge was a COM threading issue, as [QCoreApplication](/appendix/terms.md#qcoreapplication) must run within the GUI thread, and WinRT does not run the GUI within the same thread as the C runtime ([CRT](/appendix/terms.md#crt)) entry point (i.e. main()). In order to support multiple application states (normal display, background task, suspended), the application is _activated_ by a launcher - typically the Start Screen, but other options, such as file associations, are also possible. In fact, the application executable cannot be run directly - it must be activated; in some cases it might already be running but suspended. The CRT "stub" is run and must create an application view [factory class](/appendix/terms.md#factory-class) which is passed back to the launcher for instatiation. This view factory calls the Run() method, which - for GUI purposes, at least - is the logical application entry point. As this occurs in a separate thread apartment from the CRT, it is imperative that Qt applications be instantiated here (as opposed to the CRT main). For a programmer using Qt, these details must be invisible in order to prevent requiring platform-specific code. Accordingly, this startup process must execute before the the application's main() function.

<figure>
    <img src="../images/bootstrap.png" alt="Bootstrap Design" /><br />
    <figcaption>Design of the WinRT bootstrap to hide implementation detail from the programmer</figcaption>
</figure>

Fortunately, the process of "bootstrapping" a Qt application with a private main entry point is fairly common across Qt platforms. In Qt for Windows, this is accomplished by a static library called qtmain (found in qtbase/src/winmain), which does some initial setup before calling the main() entry point defined by the programmer. For WinRT, qtmain was modified to have [an alternative WinRT codepath](/appendix/gerrit.md#bootstrap) which instantiates the needed WinRT classes and then passes control to the user's main() function. A convenient workaround, the Unicode main CRT entry point (as opposed to the ANSI entry point), was used to avoid conflicts with the user's main(). Arguments from wmain are combined with any activation parameters (e.g. from the application that launched this one, such as the Start Screen or a file type association) and the application's main() is invoked with the combined argument list. Elegantly, this allows Qt for WinRT applications to require no additional configuration or manipulation of the source code in order to operate within the application container.
