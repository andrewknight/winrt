# OpenGL and Qt Quick

With Qt Quick 2 came a hard dependency on OpenGL, the de-facto standard for hardware-accelerated graphics programming. Utilizing OpenGL as the underlying platform for Qt 5's primary UI toolkit keeps the expectation of performance high while lowering the burden of supporting a parallel software rasterizer as was done with Qt Quick 1. With Qt Quick 1's [announcement of deprecation](/appendix/references.md#qt-quick-1-deprecated), the importance of the Qt Quick OpenGL Scene Graph is further reinforced. The unfortunate reality of this movement, however, is that OpenGL simply isn't part of the supported WinRT API.

While controversial, the lack of OpenGL support should probably not come to a surprise, as Microsoft supports their own graphics API, Direct3D. On the Windows platform, Direct3D has historically held better support from graphics chip vendors compared to OpenGL, largely due to the importance of popular games (including those published by Microsoft itself). With windows 8, OpenGL is labeled as a "[legacy graphics](/appendix/msdn.md#opengl)" API, no doubt encouraging even desktop developers to look toward the better-supported Direct3D. As OpenGL is unsupported for WinRT applications, Direct3D is the only choice for hardware-accelerated 3D graphics - whether through direct use or via a wrapper library.

## ANGLE
The Almost Native Graphics Layer (ANGLE) is an open-source project, primarily sponsored by Google[], which provides an OpenGL ES 2 implementation running on top of Direct3D 9. It was originally introduced to improve graphics acceleration support in Google Chrome, particularly for Windows computers with poor or buggy OpenGL drivers. Many of these machines run older Intel integrated graphics chipsets, for which more useful Direct3D drivers exist. This translates to better graphics performance in the web browser (i.e. for WebGL applications), while also providing an OpenGL ES implementation for use in other products. Qt, for example, adopted ANGLE as configuration option in its Windows-based versions. Similarly to Google Chrome and WebGL, the use of ANGLE enables use of Qt Quick on Windows machines which lack proper OpenGL support.

## Updating ANGLE
ANGLE offers a compelling solution to OpenGL on WinRT - perhaps even more than desktop Windows - given the complete lack of OpenGL support and universal support for Direct3D 11. To support Direct3D 11, though, it was first necessary to first upgrade the version of ANGLE used in Qt. This upgrade landed in Qt 5.1, based on the "dx11-proto" development branch of ANGLE. I also committed a few extra patches to resolve some failing test cases[], and to make Direct3D 9 and Direct3D 11 codepaths mutually exclusive[]. By enabling compilation of a Direct3D 11-only version of ANGLE (through the -angle-d3d11 configure option), the groundwork for using ANGLE under WinRT was laid.

## Patching ANGLE for WinRT
After updating Qt's copy of ANGLE, the Qt WinRT branch was rebased[] so that further patches of ANGLE could be made. Since ANGLE is geared toward Desktop Windows, a number of API rewrites changes were required in order to support WinRT's windowing system. Additionally, some unsupported Win32 APIs were replaced with supported versions (much like was done to Qt Core at the beginning of the porting process):
 - Thread local storage calles (TLS*) were replaced with usage of the threading attribute, __declspec(thread)[].
 - LocalAlloc/LocalFree dynamic memory methods were replaced with the newer Heap API methods[].
 - Calls to LoadLibrary() were replaced with LoadPackagedLibrary(). In the case of Direct3D 11, they were removed in favor of static initialization of the Direct3D library[].

To support the WinRT windowing system, an [EGL](/appendix/terms.md#egl) adaptation was made. EGL is an abstraction of the platform windowing system and can be used with OpenGL-based technologies to setup native display surfaces. Much like an OpenGL ES chipset vendor would do, ANGLE provides is own implementation of EGL for providing access to its version of the OpenGL ES 2 library. Within EGL, native types (e.g. window handles) are mapped to platform-independent EGL types. With this mapping in place, calls made through the EGL API are directed to platform-dependent private implementations, providing a cross-platform API to initializing the windowing system for use with OpenGL.

In order to implement EGL for WinRT, a few patches to ANGLE were required[]. In ANGLE, the EGLNativeWindowType is defined as HWND (Win32 window handle), and the EGLNativeDisplayType is defined as HDC (Win32 device context handle). These types are meaningless under WinRT, and were replaced with ICoreWindow * and int, respectively. In the private implementation, methods using EGLNativeDisplayType required minimal changes: essentially all display-dependent code was simply compiled out; mainly because WinRT does not provide a meaningful concept of "native display" - it only provides applications with a single top-level window. When compared to other EGL implementations, this is actually a quite common case: the programmer can  pass EGL_DEFAULT_DISPLAY as the native display type and let the EGL implementation handle access to the default platform display internally. In the case of WinRT, not even this is required, as all relevant information is located on the window pointer (as opposed to the display pointer). To provide a useful implementation of EGLNativeWindowType, WinRT codepaths were inserted so that ANGLE EGL could deal with initialization and state tracking where appropriate. Examples include determining the size of the window or accessing the Direct3D swap chain. The table below summarizes the changes.

Change: Win32 version: WinRT version:
EGLNativeDisplayType HDC int (unused)
EGLNativeWindowType HWND ICoreWindow *
Direct3D device
Direct3D swapChain
Direct3D flip method


## Enabling Qt Quick 2
After making the right patches to ANGLE, Qt's OpenGL layer became functional under WinRT. As long as libEGL (the EGL library), libGLESv2 (the OpenGL ES 2 library), and d3dcompiler_46 (the Direct3D shader compiler library) are packaged with the application, it is possible to render OpenGL within the Modern UI environment (at least for non-phone devices, discussed below). Assuming a JavaScript backend is available, this means that Qt Quick 2 can be built as well. If the goals of this project could be summed up into one sentence, it would be "to run Qt Quick 2 applications inside Windows 8 Modern UI". From this point of view, that goal has been met.

<image of qt app running here>

## Caveat: Direct3D Support
Of course, this is not without its caveats. Modern graphics pipelines rely on shader units - programmable cores of the GPU - to process small programs, "shaders", in parallel. While Direct3D 11 is supported on all WinRT devices, feature support (and the associated shader model) can vary. Embedded hardware (as found on phones and tablets) as well as older desktop hardware may be "feature level 9" (for Direct 3D 9) devices, having an effective shader model version 2 (SM2). With WebGL support being the primary use case for ANGLE, the project developers have kept a requirement of SM3 in order to acheive good WebGL conformance[]. Due to these contraints, the ANGLE developers have not targeted SM2 hardware in the Direct3D 11 version. While ANGLE for Direct3D 9 partially supports SM2, it takes advantage of shader model 3 (SM3) wherever possible (as a point of reference, SM4 and SM5 are supported by modern desktop hardware). Unless SM2 support is folded back into ANGLE (which community members have already started[]), these chipsets will remain without Qt Quick 2 suppport.

## Caveat: Shader Compilation
Even if ANGLE Direct 3D did support SM2 hardware already, Windows Store certification limits use of the Direct3D shader compiler library to development time only; it cannot be used in published applications. This means that developers are responsible for pre-compiling all shader programs used in their application (as opposed to creating them at run-time). This is a challenge for both ANGLE and Qt Quick, which rely on the ability to generate shader programs on-the-fly. ANGLE requires this feature to perform dynamic translation from GLSL to HLSL[], and Qt Quick does this to enable authoring of shaders from interpreted QML code[]. While applications not destined for the Windows Store (for example, line-of-business applications distributed internally) can ignore this issue, Windows Phone has the additional constraint that it does not supply a shader compiler library at all. This could potentially be solved with a drop-in replacement for the Microsoft compiler - [MojoShader], for instance, can generate Direct 3D shader bytecode. The problem remains, however, that Windows Store guidelines state that dynamically generated code is a reason to fail certification[]. A more future-proof option would be a runtime shader cache which collects all of the shaders compiled at development time. These compiled shaders could then be packaged with the application and loaded in place of their dynamically generated variants.

## Caveat: JavaScript
Another challenge for Qt Quick 2 is the need for a Windows Store-certifiable JavaScript engine. JavaScript is used as an auxilliary language in QML, allowing scripting and property bindings to work without compilation. Qt 5 ships with Qt V8, an adaptation of the Google V8 JavaScript engine. In order to compile the engine and run it within WinRT, one must disable the API guards which block Win32 APIs from being used. This is because V8, like many scripting engines, relies heavily on the virtual memory API[] for performing just-in-time ([JIT](/appendix/terms.md#jit)) compilation of JavaScript code. For reasons apparently related to the dynamic code generation constraint, the virtual memory API it is not sanctioned for Windows Store applications[], making V8 a non-option for the Windows Store. Fortunately, a solution has been developed in parallel to the WinRT port: the V4 virtual machine[]. V4 is an answer to some of the inflexibilities and misaligned use cases of the V8 JavaScript engine. It uses JIT compilation where possible, and falls back to a bytecode interpreter when JIT compilation is not supported. For normal QML use cases, particularly the evaluation of property bindings, V4 promises to have comparable performance even when JIT compilation is inactive[]. This helps to reinforce JavaScript as a syntax for use within QML, rather than a complete runtime environment for building up entire applications. C++, after all, is the primary language for use within Qt.
