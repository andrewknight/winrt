# Platform Abstraction

After getting the lower levels of the [build system and core libraries](core.md) in place, most of the remaining porting details were in QPA. QPA, as discussed earlier, abstracts the platform display and input handling for use with Qt.

## Display management
From a display management perspective, QPA plugins can be split into two basic categories: those which interface with a desktop window manager ([DWM)(/appendix/terms.md#dwm)) (such as Windows or X11) and those which don't (such as linuxfb or EGLFS). A DWM is generally responsible for managing the geometry, layering, and decorations of application windows, so a non-DWM QPA plugin typically avoids this altogether. Accordingly, applications designed to use these plugins typically consist of a single, usually fullscreen, top-level window with no decorations. This is particularly valuable in embedded and mobile contexts, where no expectation of a DWM exists. Although feature-light, the Modern UI is indeed a window manager, so the WinRT plugin should respond to changes in the application window accordingly. Even so, WinRT shares much in common with the non-DWM category of QPA plugins (perhaps even more so in the case of Windows Phone), as the operating system provides little more than a single undecorated surface for the application to draw within. Consequently, it was decided to [enforce fullscreen window behavior](/appendix/gerrit.md#default-window-handling) just as is done in the embedded and mobile QPA plugins; top-level windows are always sized to the application surface.

<img of fullscreen application>

WinRT is somewhat unique as a Qt platform in that applications are always treated as full-screen (with top-level windows using all available space), despite having the possibility that the window manager can still resize the view. Once this constraint is understood, the traditional window state (minimized, maximized, etc.) can take on new meaning - that is, parallels can be drawn between snapped/filled/fullscreen and normal/maximized/fullscreen. To take advantage of this, the snapping API, called ApplicationViewState, was shoehorned to the existing window state API. This gives developers the freedom and information to utilize the snapping paradigm: fullscreen windows take up the entire screen, filled views are considered maximized, snapped applications are marked with the no-state/normal flag, and off-screen applications are considered minimized. Applications can take advantage of this information by listening to the windowStateChanged signal and can attempt to change the window state through the existing setWindowState() API. This is somewhat restricted by the Modern UI environment, though: the platform only allows snapped applications to request to go fullscreen. Other scenarios, such as an application going from fullscreen to snapped or from hidden to visible, are only allowed by the end-user. Developers using Qt on WinRT must keep this platform constraint in mind; they may use other platform solutions, as discussed in the next chapter, to get the user's attention.

## Page Flipping with Direct3D
For Qt to be usable as a GUI toolkit, it needs a reliable and efficient way to present applications on the screen; there is always some degree of platform-specific code required for this to happen. WinRT has hardware two graphics APIs which can be used without a corresponding UI framework: Direct3D and Direct2D, both of which rely on the DirectX Graphics Interface (DXGI). In order to use these APIs, a [DXGI](/appendix/terms.md#direct3d) [swap chain](/appendix/terms.md#swap-chain) is created. For applications doing rasterizations on the CPU (such as Qt applications using the QPainter API), the swap chain can be configured for bit-block transfers ("[blitting](/appendix/terms.md#blit)"). This allows the application to copy its rendered contents to the screen in an efficient manner. In the Qt on Metro project, this was prototyped with [Direct2D](/appendix/terms.md#direct-2d), but [Direct3D](/appendix/gerrit.md#direct3d) was used for the Qt 5 version (as Direct2D is based on Direct3D, this led to a lower memory footprint and fewer dependencies).

In QPA, applications "flush" their changes to the screen using QBackingStore API, one of the classes customized for WinRT. When a change occurs, or a portion of the screen becomes "damaged", the backing store is updated and the window is notified of the change. Aligned with the vertical blanking of the display, the damaged portions are updated on the screen. In the WinRT/Direct3D implementation, a double-buffered "page flip" paradigm is used, whereby two hardware buffers are used to control the current (front) buffer and next (back) buffer. It is this back buffer which is updated when a damage event occurs, and is flipped to the screen at the next available opportunity. To further optimize flipping, non-phone devices are configured to take advantage of a Direct3D 11.1 API which flips only the damaged portions to the screen (as opposed to the entire buffer)[]. Phone devices, on the other hand, have different graphics hardware which restricts the configuration to single hardware buffers with wholesale page flips[].

While this style of software rasterization and hardware blitting allow for many types of applications to function at an acceptable framerate, it has limitations when the CPU cannot draw frames quickly enough to provide smooth animation. This can certainly be the case of highly-dynamic, animation rich content, and is a major reason why the Qt Quick 2 Scene Graph was created. Without hardware-accelerated drawing, the GPU is not very well utilized; it does little more than handling buffer transfers into graphics memory. To take advantage of hardware capabilities - and enable smoother animations and other graphical effects - a graphics API such as Direct3D or OpenGL should be used. As Qt has standardized on OpenGL for powering the Qt Quick 2 (as well as several other graphics modules in the Qt framework), it is the only relevant option in this case. Overcoming this challenge is the subject of the next chapter.

## Key handling
Key handling can be a surprisingly complex task, as applications must consider variables such as different keyboard layouts, system locales, special key combinations (such as Alt character escapes), and input from software input methods like on-screen keyboards and handwriting recognition systems. In order to get a "somewhat working" approach, an [initial key mapper](/appendix/gerrit.md#initial-key-mapper) was written based on the existing Win32 code. A key mapper is designed to take native input - on Windows, called a "virtual key" - and map it to a Qt::Key enumeration value. If the keystroke corresponds to a textual character, this text string must also be computed. When the input mapping is accurate, the key mapper can accommodate all sorts of key combinations and layouts. When the keymapping is inaccurate, keyboard can become practically useless. This was the case with the initial key mapping attempts, as most special characters and meta keys were not handled - making typing non-alphanumeric characters impossible.

After further review, it was determined that key handling in WinRT was not as tricky as originally thought - an additional event handler just needed to be installed[]. Windows are sent messages not only for key presses and releases, but also for characters (in cases where a keystroke generates a character). These character messages are already translated into UTF16 strings (required by QString) based on the user's key layout and locale, so no application-level translation is required (apart from meta keys, which require special attention as to not send non-printable characters to input controls). As Qt only expects to receive key events (not character events), it is the job of the platform plugin to map the incoming character events to the interleaved key events - or, in the case of "spontaneous" characters (e.g. those those coming from another application) to generate simulated key events for the character. In the end, the implementation proved simpler than the Win32 version, as WinRT handles keystroke translation and even filters out and translates special key combinations (such as Alt-numberpad characters) before they reach the application.

<figure>
    <img touch keyboard /><br />
    <figurecaption>The "wiggly" Qt demo running on Windows 8 tablet (left) and Windows Phone 8 (right) with touch keyboards open. Non-phone devices challenge the programmer to provide the operating system with accessibility information rather than allowing direct invocation of the touch keyboard.</figurecaption>
</figure>

To round out the key handling implementation, it was important to address the issue of software input methods as well. After all, the platform is geared largely towared devices with touch screens, many of which may not even have a hardware keyboard. QPA provides an API that allows applications to request that the touch keyboard be opened or closed, as well as querying its screen geometry, allowing applications to adjust the view of the application accordingly. For Windows Phone, a special phone-only keyboard API allows for a direct mapping to the Qt abstraction, making [touch keyboard handling straightforward](/appendix/gerrit.md#touch-keyboard). For non-phone devices, the situation is less clear. If a device (such as a tablet) has a touch screen, the touch keyboard may appear when a text input control has focus. This is done automatically by XAML and HTML controls, but cannot be done by DirectX applications (as Qt is under WinRT) without informing the operating system about text accessibility through the UI Automation API (UIA). Through the implementation of UIA interfaces, the runtime environment will query the application for accessibility information when certain user actions, such as touch events, occur. The application can then return information about the bounding rectangles of text controls, so that the windowing system itself can determine whether or not to open the keyboard. While the programmer is not able to directly open the keyboard, the keyboard _should_ still open when needed. Of course, this becomes challenging with a framework like Qt, where the developer can design any sort of input control they wish. In order to support this generic use case (as opposed to a QWidget- or QQuickItem-based approach), an additional QInputMethodQuery enum value, Qt::ScreenRectangle, was added so that any object can report its screen coordinates should it choose to do so.

## Pointer handling
Pointer handling in WinRT is interesting because it supports mice, touchscreens, and pen events within the same pointer event structure. QPA requires these be be sent to the application as separate event types, so the first step in the pointer handling logic is to forward the event to there respective handler. Once there, the position and status information of the pointer event is extracted and sent to the window system interface. Mouse-like devices provide the button state (up to five mouse buttons are represented in the WinRT API) and pen-like devices give additional information such as tilt, pressure, and rotation. In the case of touchscreens (and some trackpads), touch points are tracked over time and marked as "pressed", "stationary", "moved", or "released". Overall, pointer handling was straightforward, although one caveat was discovered: on phone devices, the "isOnContact" property always returns true, even if the touch point had been released. It was discovered that the "isLeftButtonPressed" property could be used instead to provide the actual state of the touch point.

Another requirement of pointer handling, at least for mouse events, is setting of the cursor image. Since Qt applications do their own painting, the operating system must be informed when the mouse cursor needs to change its visual identity, such as when hovering over a link or resizing a control. [Integration of this requirement](/appendix/gerrit.md#mouse-cursor) was fairly straightforward, although a few challenges were discovered. While most of the cursor shapes requested by Qt are available in the WinRT API, a few notable icons are absent: split resizers (**inline image**) and open/closed hands (**inline image**). This isn't a critical issue in itself, as these cursors can be embedded into the application binary (although they may not match the user's active cursor theme). This is complicated by another fact of the WinRT API: a custom cursor can only be loaded from a resource ID, not e.g., an array of bytes (as was possible in Win32). This also means that dynamic cursors are not possible within this API, unless the developer can find a way to dynamically build resources (which [should be technically possible](/appendix/references.md#dynamic-linking)). Another workaround would be to hide the native cursor and perform custom cursor composition in the graphics pipeline, an approach used by other platform plugins such as EGLFS. While being a more transparent approach, it would have performance implications due to the added compositions and potential OpenGL context switches. Both solutions are yet to be investigated.

With pointer handling mostly in place - particularly touch handling - the ability to manipulate objects using pinch, pan, and zoom gestures is simple with Qt APIs like the QML PinchArea. While most gesture use cases are now covered, there is an additional API which is not yet integrated - the native gestures API, which maps gesture events from the operating system to Qt's standard set of gestures. WinRT supports a number of [predefined gestures](/appendix/msdn.md#gestures) for use in applications. In the QPA sense, these gestures events should be caught, converted into Qt gesture events, and delivered to the application. As additional consideration is needed to understand the mapping between WinRT gestures and Qt gestures, this topic requires further investigation.

## System Service Integration
Currently, QPA provides integration of two "destkop" services: URL handling and file opening/launching. URLs typically point to webpages (but may point to any resource); files are typically documents known to (and specified by) the user. Both open with the default application associated with the URL or file format. Supporting these services was simple to [implement](/appendix/gerrit.md#desktop-services), as WinRT readily supports these use cases. Even so, a curious challenge was discovered: both WinRT APIs are asynchronous, while the QPA support for them is expected to be synchronous. To make a non-blocking API blocking, an approach borrowed from Qt's dialog system was borrowed: we use a local event loop to process all GUI events until the asynchronous operation completes. Doing so allows the programmer to be informed whether the open operation succeeded, while keeping the GUI responsive during the procedure. In style-enforcing fashion, Windows even adds the "busy indicator" (**inline image**) to the mouse cursor automatically, notifying the user of a possibly long-running event (and relieving the programmer of that duty).

Another "service" provided by the WinRT API (and described by QPA) is the display orientation event. When the user changes the device's screen orientation - whether it be through the Control Panel or by physically rotating the device - an event is raised which informs the application of the change. In some environments, the operating system may change the screen resolution (swapping with & height) automatically. In other environments, such as on Window Phone, the application resolution remains the same (making it the responsibility of the application developer to take advantage of the event if desired). Quite conveniently, a 1:1 mapping was found between the WinRT API and the QPA API, resulting in a straightforward solution in [implementation](/appendix/gerrit.md#orientation).

With the basic elements of QPA in place, the platform starts to come alive. Qt applications can draw to the screen, receive input from the user, and even tap into some integration points of the operating system. With these capabilities in place, the Qt for WinRT port provides convincing evidence that a successful port is possible on the platform. With these essential user interface primitives in place, most other aspects of Qt fall in line easily.

[Previous: Core Issues](core.md) | [Next: OpenGL & Qt Quick](opengl.md)
