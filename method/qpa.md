# Qt Platform Abstraction

With the lower levels of the [build system and core libraries](core.md) in place, most of the remaining porting details could be addressed QPA. This section describes how the QPA API was integrated with WinRT to provide support for display management, input handling, and basic desktop services.

## Display management
From a display management perspective, QPA plugins can be split into two basic categories: those which interface with a desktop window manager ([DWM](/appendix/terms.md#dwm)) (such as Windows or X11) and those which don't (such as [LinuxFB](/appendix/terms.md#linuxfb) or [EGLFS](/appendix/terms.md#eglfs)). A DWM is generally responsible for managing the geometry, layering, and decorations of application windows, so a non-DWM QPA plugin typically avoids this altogether. Accordingly, applications designed to use these plugins typically consist of a single fullscreen window with no [chrome](/appendix/terms.md#window-chrome) (window decorations). This is particularly valuable in embedded and mobile contexts, where no expectation of a DWM exists. Although feature-light, the Modern UI is indeed a window manager, so the WinRT plugin should respond to changes in the application window accordingly. Even so, WinRT shares much in common with the non-DWM category of QPA plugins (perhaps even more so in the case of Windows Phone), as the operating system provides little more than a single undecorated surface for the application to draw within. Consequently, it was decided to [enforce fullscreen window behavior](/appendix/gerrit.md#54284) just as is done in the embedded and mobile QPA plugins; top-level windows are always sized to the application surface.

As a consequence of the embedded-style fullscreen paradigm combined with the ability to resize the viewport, WinRT becomes somewhat unique as a hybrid Qt platform. One advantage of this unique combination is that the traditional window state (minimized, maximized, etc.) can take on new meaning - that is, parallels can be drawn between the snapped/filled/fullscreen paradigm of Modern UI and the traditional normal/maximized/fullscreen system seen in mainstream desktop environments. To take advantage of this, the WinRT snapping API - [ApplicationViewState(/appendix/msdn.md#applicationviewstate) - was [mapped to the existing window state API](/appendix/gerrit.md#57056). This gives developers the freedom and information to utilize the snapping paradigm: fullscreen windows take up the entire screen, filled views are considered maximized, snapped applications are marked with the no-state/normal flag, and off-screen applications are considered minimized. Applications can take advantage of this information by listening to the windowStateChanged signal and attempt to change the window state through the existing setWindowState() API. This is somewhat restricted by the Modern UI environment, though: the platform only allows snapped applications to request to go fullscreen. This is to put the user in control of the environment, not the application. There are other mechanisms for grabbing a user's attention, though, and these are discussed in the [chapter on UI integration](/method/ui.md).

## Writing to the Screen
For Qt to be usable as a GUI toolkit, it needs a reliable and efficient way to present applications on the screen; there is always some degree of platform-specific code required for this to happen. For pure C++ applications on WinRT, developers must use one of two graphics APIs: [Direct3D](/appendix/gerrit.md#direct3d) or [Direct2D](/appendix/terms.md#direct-2d), both which utilize the DirectX Graphics Interface ([DXGI](/appendix/terms.md#direct3d)). For these interfaces, a DXGI [swap chain](/appendix/terms.md#swap-chain) is created which allows the presentation of framebuffers - that is, buffers holding the video frame to be displayed to the user - to the screen. For applications doing rasterizations on the CPU (such as Qt applications using the QPainter API), the swap chain can be configured for bit-block transfers ("[blitting](/appendix/terms.md#blit)"), allowing the application to render its contents to the screen in an efficient manner. The use of this mechanism was prototyped with Direct2D in the Qt on Metro project, but was [rewritten with Direct3D in Qt 5](/appendix/gerrit.md#46917).

In QPA, applications "flush" their changes to the screen using QBackingStore API, one of several classes customized for WinRT. When a portion of the screen becomes changed - or "damaged" - the backing store is updated and the window is notified of the damage. Aligned with the vertical blanking of the display, the image on the screen is updated to the contents of the backing store. In the WinRT/Direct3D implementation, a double-buffered "page flip" paradigm is used, whereby two hardware buffers are used to control the current (front) buffer and next (back) buffer. It is this back buffer which is updated when a damage event occurs, and is flipped to the screen at the next available opportunity. To further optimize flipping, non-phone devices are configured to take advantage of a Direct3D 11.1 API which flips only the damaged portions to the screen (as opposed to the entire buffer). Phone devices, on the other hand, have different graphics hardware which restricts the configuration to single hardware buffers with [wholesale page flips](/appendix/gerrit.md#54547). To Qt applications, this distinction is transparent - raster windows make their way to the screen via the QBackingStore API. OpenGL windows, however - such as those used in Qt Quick - cannot do this, are the subject of the [next chapter](/method/opengl.md).

## Key handling
Key handling can be a surprisingly complex task, as applications must consider variables such as different keyboard layouts, system locales, special key combinations (such as Alt character escapes), and input from software input methods like on-screen keyboards and handwriting recognition systems. In order to get a "somewhat working" approach, an [initial key mapper](/appendix/gerrit.md#initial-key-mapper) was written based on the existing Win32 code. A key mapper is designed to take native input - on Windows, called a "virtual key" - and map it to a Qt::Key enumeration value. If the keystroke corresponds to a textual character, this text string must also be computed. This can require support for hundreds of different keyboard layouts and input systems, and Qt typically relies on features of the platform to handle this. When the keymapping is inaccurate, characters are misdetected, and keyboard input can be practically unusable. This was the case in early versions of Qt for WinRT, which offered [rudimentary support](/appendix/gerrit.md#50827).

After further review, a better key handling scheme was derived from the window's [character event handler](/appendix/gerrit.md#52603). Windows are sent messages not only for key presses and releases, but also for characters (in cases where a keystroke generates a character). These character messages are already translated into UTF16 strings (required by QString) based on the user's key layout and locale, so no application-level translation is required (apart from meta keys, which require special attention as to not send non-printable characters to input controls). As Qt only expects to receive key events (not character events), it is the job of the platform plugin to map the incoming character events to the interleaved key events - or, in the case of "spontaneous" characters (e.g. those those coming from another application) to generate simulated key events for the character. In the end, the implementation proved simpler than the Win32 version, as WinRT handles keystroke translation and even filters out and translates special key combinations (such as Alt-numberpad characters) before they reach the application.

![Wiggly Demo](/images/wiggly.png)
^ The "Wiggly" Qt demo running under Windows 8 (left) and Windows Phone 8 (right) with touch keyboards open. The system controls the visibility of the touch keyboard on non-phone devices; a touch screen is required to be interacted with before the software input method can be displayed.

To round out the key handling implementation, it was important to address the issue of software input methods as well. After all, the platform is geared largely towared devices with touch screens, many of which may not even have a hardware keyboard. QPA provides an API that allows applications to request that the touch keyboard be opened or closed, as well as querying its screen geometry, allowing applications to adjust the view of the application accordingly. For Windows Phone, a special phone-only keyboard API allows for a direct mapping to the Qt abstraction, allowing touch keyboard visibility to [map nicely to QPA](/appendix/gerrit.md#56450). For non-phone devices, though, the situation is less optimal. If a device (such as a tablet) has a touch screen, the touch keyboard may appear when a text input control has focus. This is done automatically by XAML and HTML controls, but cannot be done by DirectX applications (as Qt is under WinRT) without informing the operating system about text accessibility through the UI Automation API (UIA). Through the implementation of UIA interfaces, the runtime environment will query the application for accessibility information when certain user actions, such as touch events, occur. The application can then return information about the bounding rectangles of text controls, so that the windowing system itself can determine whether or not to open the keyboard. While the programmer is not able to directly open the keyboard, the keyboard _should_ still open when needed. Of course, this becomes challenging with a framework like Qt, where the developer can design any sort of input control they wish. In order to support this generic use case (as opposed to a QWidget- or QQuickItem-based approach), an additional QInputMethodQuery enum value, Qt::ScreenRectangle, was added so that any object can report its screen coordinates [should it choose to do so](/appendix/gerrit.md#00000). This allows for more accurate information to be given the to system regarding the locations of input controls, allowing the software keyboard to appear when those items are tapped.

## Pointer handling
Pointer handling in WinRT is interesting because it supports mice, touchscreens, and pen events within the same pointer event structure. QPA requires these be be sent to the application as separate event types, so the first step in the pointer handling logic is to forward the event to there respective handler. Once there, the position and status information of the pointer event is extracted and sent to the window system interface. Mouse-like devices provide the button state (up to five mouse buttons are represented in the WinRT API) and pen-like devices give additional information such as tilt, pressure, and rotation. In the case of touchscreens (and some trackpads), touch points are tracked over time and marked as "pressed", "stationary", "moved", or "released". Pointer handling was straightforward to implement, albeit with some [refactoring](/appendix/gerrit.md#54383) in the process. One rather interesting caveat was discovered: on phone devices, the "isOnContact" property always returns true, even if the touch point had been released - that is, the software did not properly report the contact state of the touch point. Interestingly, it was discovered that the "isLeftButtonPressed" property could be used instead to [provide the actual state of the touch point](/appendix/gerrit.md#55379). With pointer handling mostly in place - particularly touch handling - the ability to manipulate objects using pinch and pan gestures is simple with Qt APIs like the Qt Quick [PinchArea](/appendix/qdoc.md#pincharea).

Another requirement of pointer handling, at least for mouse events, is setting of the cursor image. Since Qt applications do their own painting, the operating system must be informed when the mouse cursor needs to change its visual identity, such as when hovering over a link or resizing a control. While [integration of this requirement](/appendix/gerrit.md#mouse-cursor) was quite simple, a few limitations were discovered. While most of the cursor shapes requested by Qt are available in the WinRT API, a few notable icons are absent: split resizers (□) and open/closed hands (□). This isn't a critical issue in itself, as any missing cursors can be embedded into the application binary (although they may not match the user's active cursor theme). This is, however, complicated by another fact of the WinRT API: a custom cursor can only be loaded from a resource ID, not e.g., an array of bytes (as was possible in Win32). This also means that dynamic cursors are not possible within this API (that is, cursors painted into memory). A workaround to this issue would be to hide the native cursor and perform custom cursor composition within the graphics pipeline, an approach used by other platform plugins such as EGLFS. This is likely the most robust solution, although with some added overhead, and is yet to be investigated further.

## System Service Integration
Currently, QPA provides integration of two "destkop" services: URL handling and file opening/launching. URLs typically point to webpages (but may point to any resource); files are typically documents known to (and specified by) the user. Both open with the default application associated with the URL or file format. Supporting these services was simple to [implement](/appendix/gerrit.md#54374), as WinRT readily supports these use cases. Even so, a curious challenge was discovered: both WinRT APIs are asynchronous, while the QPA support for them is expected to be synchronous. To make a non-blocking API blocking, an approach borrowed from Qt's dialog system was borrowed: use a local event loop to process all GUI events until the asynchronous operation completes. Doing so allows the programmer to be informed whether the open operation succeeds, while keeping the GUI responsive during the procedure. In style-enforcing fashion, Windows even adds the "busy indicator" (□) to the mouse cursor automatically, notifying the user of a possibly long-running event (and relieving the programmer of that duty).

Another "service" provided by the WinRT API (and described by QPA) is the display orientation event. When the user changes the device's screen orientation - whether it be through the Control Panel or by physically rotating the device - an event is raised which informs the application of the change. In some environments, the operating system may change the screen resolution (swapping with & height) automatically. In other environments, such as on Window Phone, the application resolution remains the same (making it the responsibility of the application developer to take advantage of the event if desired). Quite conveniently, a 1:1 mapping was found between the WinRT API and the QPA API, resulting in a clean [implementation](/appendix/gerrit.md#54575).

With the basic elements of QPA in place, the platform starts to come alive. Qt applications can draw to the screen, receive input from the user, and even integrate with some finer points of the operating system. With these capabilities in place, the Qt for WinRT port provides convincing evidence that a successful port is possible on the platform. With these essential user interface primitives in place, there is encouragement that other aspects of the framework will fall in line.

[Previous: Core Issues](core.md) | [Next: OpenGL & Qt Quick](opengl.md)
