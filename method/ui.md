# UI Details

## Platform Menus and Dialogs

## QWidgets
While Qt Widgets aren't being active developed [], they do make for good set of ready-made components for rapidly creating and testing the functionality of the UI. With the move to Qt 5 & QPA, widgets tend to work "out of the box" as long as they use the fully-painted codepaths (and not the platform style plugin). This can be a major advantage on devices where OpenGL is not yet functional (and therefore Qt Quick cannot be used). Widgets are simply raster surfaces, and can be used within the performance constraints of the CPU-bound painting system. This includes the Qt Graphics View, a 2D canvas and foundation for Qt Quick 1.

<screenshots of widget apps running on tablet and phone>

### Native styling
As there is no concept of desktop controls (widgets) - in the Modern UI, Qt widgets do look a bit out of place here. While styling them is possible, it seems a fruitless undertaking given the new Qt Quick Controls styling API []. Apart from the native menu investigation of the previous chapter, no attempt to create a native component set has yet been started. The most appropriate option for native stying would be to study the XAML components carefully and provide Qt Quick equivalents of their look and feel. This is, after all, the same basic principle that has been applied with existing Qt style plugins - the difference being that the implementor has the advantage of using Qt Quick instead of the aging QPainter/QStyle API.

## Qt Quick
## Quick!
Qt Quick evolved over the course of Qt 4.7 and 4.8, finding its place on [Nokia's smartphone platforms](/appendix/references.md#meego), MeeGo and Symbian. Large improvements to Qt Quick came with Qt Quick 2.0 (as a part of Qt 5), which introduced a hardware-accelerated scene graph based on OpenGL. Through better use of graphics hardware and a reduced emphasis on native styling, Qt Quick can run slimmer and perform better on the wide array of platforms that Qt supports.

Despite its proliferation, C++ has not been the only cross-platform language base available. Java for instance, runs on nearly as many platforms and competes for a high programmer usage []. With the (*Web technologies) boom, it could also be argued that (*HTML5) provides an even broader set of screens in which application developers can reach[]. Within that same category of frameworks exist many more competitors that offer a common API to a variety of platforms; notable examples such as (*Adobe Air), (*WxWidgets), and (*Appcelerator) to name a few.

Qt, however, may be the oldest and richest of these options, given that it is supported on at least 12[] different operating systems and has been in active development for over 20 years. In recent times, it has gained a surge in popularity and availability thanks to the contributions of Nokia, who developed Qt for its Symbian and Maemo/MeeGo platforms from 2008-2012 and released Qt under and an additional open-source license (LGPL) which encouraged massive contributions from the community. Under Nokia, the Qt Platform Abstraction ((*QPA)) API was developed, which fostered future platform support (e.g. Android and iOS) following Digia's acquisition of Qt in 2012.

Enabling Qt Quick on WinRT was essentially a matter of using ANGLE as the OpenGL ES stack and switching to the new JavaScript engine, V4. After that, most other details fell into place...

### JavaScript challenges
A challenge of the WinRT sandbox is that memory can not be dynamically marked as executable, a practice commonly used in a technique known as "just in time" [JIT](/appendix/terms.md#jit) compilation. JIT is important for interpreted languages, such as JavaScript, which are parsed and executed at runtime. It uses in-memory compilation techniques to create machine code on-the-fly and execute it, which tends to get better performance than a comparable bytecode state interpreter. However, sandbox restrictions on the platform - as well as [Windows Store requirements](), which state that an application must not generate code at runtime, make JIT compilation a feature that must be avoided on WinRT.

In Qt 4, [Qt Script](/appendix/terms.md#qt-script) (a scripting engine based on [JavaScript Core](/appendix/terms.md#jsc)) powered [Qt Declarative](/appendix/terms.md#qt-declarative) and Qt Quick 1, the Qt developers decided to take a different approach in Qt 5 and use the [Google V8 Javascript engine](/appendix/terms.md#v8). In Qt 5.0 and 5.1, the Qt QML module relied on a repository known as "qtjsbackend", which implemented a Qt wrapper on top of V8 (the module is known as [Qt V8](/appendix/terms.md#qt-v8)). While this approach provided a performant JavaScript engine, it did not provide [a clean abstraction or optimized use cases for QML](/appendix/references.md#qt-v4vm), nor does it offer a way to disable JIT. As a result, a new engine was begun known as "V4", based on the V4 concept that had already been introduced to provide [optimized bindings for QML](/appendix/references.md#kdab-v4-blog-post). The V4 virtual machine provides optional JIT compilation and is fully integrated into the qtdeclarative repository, allowing platforms such as WinRT to run JavaScript without the external dependency of V8 or the requirement of JIT support. For the case of QML expression bindings - the most common scripting use case in Qt - performance is nearly the same as with JIT enabled [###this needs to be tested; this is based on what Lars told me in IRC].

## More challenges await

While it has been possible to get QML working on the phone (and both Quick and QML working on PCs), ANGLE DX11 does not yet have support for Feature Level 9 devices []. This is a problem for Windows ARM devices (i.e. tablets and phones), as current embedded GPUs only support this feature level, making ANGLE useless on these platforms until ANGLE is patched to support them. As this might possibly never happen [], these chipsets might never be supported for running Qt Quick 2.

Another challenge with ANGLE is its reliance (and Qt Quick's reliance, for that matter) on the ability to compile and link [GPU shader](/appendix/terms.md#shader) code at runtime. This is common practice for applications, as it makes graphics programming easier by allowing the shader code to be generated at runtime. However, the Windows Store does not allow such applications in the Store, citing both "user experience issues" (the device should not waste CPU and battery life on something that can be compiled before hand) and "generated code" issues (a similar problem to the JIT issue noted earlier). At least under WinRT (though not WinPhone), it is still possible to use the dynamic shader compiler (D3DCompiler); it simply isn't allowed in the Windows Store. For Qt, this is not a total loss though, as many Qt customers will be content to deploy their applications via [side-loading] or simply by using a [developer license]. Nonetheless, a solution should be found in the long-term in order to ensure that Qt Quick 2 can reach these device targets.

